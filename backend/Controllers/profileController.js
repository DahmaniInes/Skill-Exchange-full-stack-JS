const User = require("../Models/User");
const bcrypt = require("bcrypt");
const cloudinary = require('cloudinary').v2;

// ðŸ“Œ RÃ©cupÃ©rer le profil utilisateur
const getUserProfile = async (req, res) => {
  try {
    const user = await User.findById(req.user.id)
      .select("-password")
      .populate('experiences')
      .populate('educations')
      .populate('skills');
    
    if (!user) return res.status(404).json({ message: "Utilisateur non trouvÃ©" });
    
    res.json(user);
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
};

// ðŸ“Œ Mettre Ã  jour le profil utilisateur
const updateProfile = async (req, res) => {
  try {
    const userId = req.user.id;
    const user = await User.findById(userId);
    
    if (!user) return res.status(404).json({ message: "Utilisateur non trouvÃ©." });

    const { 
      firstName, lastName, phone, bio, location, jobTitle, 
      company, university, degree, socialLinks, 
      privacySettings, notifications, status 
    } = req.body;

    const updateData = {
      firstName, lastName, phone, bio, location, 
      jobTitle, company, university, degree, 
      socialLinks, privacySettings, notifications, status
    };

    // Gestion de l'avatar
    if (req.file) {
      if (user.profilePicture && user.profilePicture.includes('cloudinary.com')) {
        const publicId = user.profilePicture.split('/').pop().split('.')[0];
        await cloudinary.uploader.destroy(publicId);
      }

      const avatarResult = await cloudinary.uploader.upload(req.file.path, { folder: "avatars" });
      updateData.profilePicture = avatarResult.secure_url;
    }

    // Mise Ã  jour du CV
    if (req.files && req.files.cv) {
      if (user.cv) {
        const publicId = user.cv.split('/').pop().split('.')[0];
        await cloudinary.uploader.destroy(publicId, { resource_type: "raw" });
      }
      const cvResult = await cloudinary.uploader.upload(req.files.cv.path, { 
        folder: "cv", 
        resource_type: "raw" 
      });
      updateData.cv = cvResult.secure_url;
    }

    // Mise Ã  jour des compÃ©tences
    if (req.body.skills) {
      const skillsToSave = req.body.skills.map(skill => ({
        name: skill.name,
        level: skill.level || "Beginner",
        yearsOfExperience: skill.yearsOfExperience || 0
      }));
      
      await Skill.deleteMany({ user: userId });
      const savedSkills = await Skill.insertMany(
        skillsToSave.map(skill => ({ ...skill, user: userId }))
      );
      updateData.skills = savedSkills.map(s => s._id);
    }

    // Mise Ã  jour des expÃ©riences
    if (req.body.experience) {
      await Experience.deleteMany({ user: userId });
      const savedExperiences = await Experience.insertMany(
        req.body.experience.map(exp => ({ 
          ...exp, 
          user: userId 
        }))
      );
      updateData.experiences = savedExperiences.map(e => e._id);
    }

    // Mise Ã  jour de l'Ã©ducation
    if (req.body.education) {
      await Education.deleteMany({ user: userId });
      const savedEducations = await Education.insertMany(
        req.body.education.map(edu => ({ 
          ...edu, 
          user: userId 
        }))
      );
      updateData.educations = savedEducations.map(e => e._id);
    }

    const updatedUser = await User.findByIdAndUpdate(
      userId, 
      { $set: updateData }, 
      { new: true }
    ).populate('experiences educations skills');
    
    res.status(200).json({ 
      message: "Profil mis Ã  jour avec succÃ¨s.", 
      user: updatedUser 
    });
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: "Erreur serveur.", error: error.message });
  }
};

// ðŸ“Œ Mettre Ã  jour le mot de passe
const updatePassword = async (req, res) => {
  try {
    const { oldPassword, newPassword } = req.body;
    const user = await User.findById(req.user.id);
    
    if (!user) return res.status(404).json({ message: "Utilisateur non trouvÃ©" });

    const isMatch = await bcrypt.compare(oldPassword, user.password);
    if (!isMatch) return res.status(400).json({ message: "Ancien mot de passe incorrect" });

    user.password = await bcrypt.hash(newPassword, 10);
    await user.save();
    
    res.json({ message: "Mot de passe mis Ã  jour avec succÃ¨s" });
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
};

// ðŸ“Œ Ajouter une expÃ©rience
const addExperience = async (req, res) => {
  try {
    const userId = req.user.id;
    const experienceData = { 
      ...req.body, 
      user: userId 
    };

    const newExperience = new Experience(experienceData);
    const savedExperience = await newExperience.save();
    
    await User.findByIdAndUpdate(
      userId, 
      { $push: { experiences: savedExperience._id } },
      { new: true }
    );

    res.status(201).json(savedExperience);
  } catch (error) {
    res.status(500).json({ message: 'Erreur lors de l\'ajout de l\'expÃ©rience', error: error.message });
  }
};

// ðŸ“Œ Supprimer une expÃ©rience
const deleteExperience = async (req, res) => {
  try {
    const userId = req.user.id;
    const { experienceId } = req.params;

    const experience = await Experience.findById(experienceId);
    if (!experience || experience.user.toString() !== userId) {
      return res.status(404).json({ message: 'ExpÃ©rience non trouvÃ©e' });
    }

    await Experience.findByIdAndDelete(experienceId);
    
    await User.findByIdAndUpdate(
      userId,
      { $pull: { experiences: experienceId } },
      { new: true }
    );

    res.status(200).json({ message: 'ExpÃ©rience supprimÃ©e avec succÃ¨s' });
  } catch (error) {
    res.status(500).json({ message: 'Erreur lors de la suppression de l\'expÃ©rience', error: error.message });
  }
};

// ðŸ“Œ Ajouter une formation
const addEducation = async (req, res) => {
  try {
    const userId = req.user.id;
    const educationData = { 
      ...req.body, 
      user: userId 
    };

    const newEducation = new Education(educationData);
    const savedEducation = await newEducation.save();
    
    await User.findByIdAndUpdate(
      userId, 
      { $push: { educations: savedEducation._id } },
      { new: true }
    );

    res.status(201).json(savedEducation);
  } catch (error) {
    res.status(500).json({ message: 'Erreur lors de l\'ajout de la formation', error: error.message });
  }
};

// ðŸ“Œ Supprimer une formation
const deleteEducation = async (req, res) => {
  try {
    const userId = req.user.id;
    const { educationId } = req.params;

    const education = await Education.findById(educationId);
    if (!education || education.user.toString() !== userId) {
      return res.status(404).json({ message: 'Formation non trouvÃ©e' });
    }

    await Education.findByIdAndDelete(educationId);
    
    await User.findByIdAndUpdate(
      userId,
      { $pull: { educations: educationId } },
      { new: true }
    );

    res.status(200).json({ message: 'Formation supprimÃ©e avec succÃ¨s' });
  } catch (error) {
    res.status(500).json({ message: 'Erreur lors de la suppression de la formation', error: error.message });
  }
};

// ðŸ“Œ Ajouter une compÃ©tence
const addSkill = async (req, res) => {
  try {
    const userId = req.user.id;
    const skillData = { 
      ...req.body, 
      user: userId 
    };

    const newSkill = new Skill(skillData);
    const savedSkill = await newSkill.save();
    
    await User.findByIdAndUpdate(
      userId, 
      { $push: { skills: savedSkill._id } },
      { new: true }
    );

    res.status(201).json(savedSkill);
  } catch (error) {
    res.status(500).json({ message: 'Erreur lors de l\'ajout de la compÃ©tence', error: error.message });
  }
};

// ðŸ“Œ Supprimer une compÃ©tence
const deleteSkill = async (req, res) => {
  try {
    const userId = req.user.id;
    const { skillId } = req.params;

    const skill = await Skill.findById(skillId);
    if (!skill || skill.user.toString() !== userId) {
      return res.status(404).json({ message: 'CompÃ©tence non trouvÃ©e' });
    }

    await Skill.findByIdAndDelete(skillId);
    
    await User.findByIdAndUpdate(
      userId,
      { $pull: { skills: skillId } },
      { new: true }
    );

    res.status(200).json({ message: 'CompÃ©tence supprimÃ©e avec succÃ¨s' });
  } catch (error) {
    res.status(500).json({ message: 'Erreur lors de la suppression de la compÃ©tence', error: error.message });
  }
};

// ðŸ“Œ Mettre Ã  jour les liens sociaux
const updateSocialLinks = async (req, res) => {
  try {
    const user = await User.findById(req.user.id);
    user.socialLinks = { ...user.socialLinks, ...req.body };
    await user.save();
    
    res.json(user.socialLinks);
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
};

// ðŸ“Œ Uploader un CV
const uploadCV = async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ message: "Aucun fichier trouvÃ©" });
    }

    const user = await User.findById(req.user.id);

    // Supprimer l'ancien CV s'il existe
    if (user.cv) {
      await cloudinary.uploader.destroy(user.cv, { resource_type: "raw" });
    }

    // TÃ©lÃ©verser le nouveau CV
    const cvResult = await cloudinary.uploader.upload(req.file.path, { 
      folder: "cv", 
      resource_type: "raw" 
    });

    user.cv = cvResult.secure_url;
    await user.save();

    res.json({ message: "CV mis Ã  jour avec succÃ¨s", cvUrl: user.cv });
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
};

// ðŸ“Œ Supprimer le CV
const deleteCV = async (req, res) => {
  try {
    const user = await User.findById(req.user.id);
    
    if (!user.cv) {
      return res.status(404).json({ message: "Aucun CV Ã  supprimer" });
    }

    // Supprimer de Cloudinary
    await cloudinary.uploader.destroy(user.cv, { resource_type: "raw" });

    // Mettre Ã  jour l'utilisateur
    user.cv = null;
    await user.save();

    res.json({ message: "CV supprimÃ© avec succÃ¨s" });
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
};

// ðŸ“Œ Ajouter une Ã©valuation
const addRating = async (req, res) => {
  try {
    const { rating, comment } = req.body;
    const user = await User.findById(req.params.id);
    
    if (!user) return res.status(404).json({ message: "Utilisateur non trouvÃ©" });

    user.ratings.push({ 
      reviewer: req.user.id, 
      rating, 
      comment 
    });

    // Recalculer la moyenne des notes
    const totalRatings = user.ratings.length;
    const sumRatings = user.ratings.reduce((sum, r) => sum + r.rating, 0);
    user.averageRating = sumRatings / totalRatings;

    await user.save();
    res.json(user);
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
};

// ðŸ“Œ Basculer la confidentialitÃ© du profil
const toggleProfilePrivacy = async (req, res) => {
  try {
    const user = await User.findById(req.user.id);
    user.privacySettings.isProfilePublic = !user.privacySettings.isProfilePublic;
    await user.save();
    
    res.json({ isProfilePublic: user.privacySettings.isProfilePublic });
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
};

// ðŸ“Œ Obtenir un profil public
const getPublicProfile = async (req, res) => {
  try {
    const user = await User.findById(req.params.id)
      .select("firstName lastName bio skills profilePicture")
      .populate('skills')
      .populate('experiences')
      .populate('educations');
    
    if (!user || !user.privacySettings.isProfilePublic) {
      return res.status(403).json({ message: "Ce profil est privÃ© ou n'existe pas" });
    }
    
    res.json(user);
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
};

// ðŸ“Œ Obtenir les recommandations de profil
const getProfileRecommendations = async (req, res) => {
  try {
    const userId = req.user.id;
    const user = await User.findById(userId)
      .populate('skills')
      .populate('experiences');

    // Logique de recommandation basÃ©e sur les compÃ©tences et expÃ©riences
    const recommendations = {
      similarProfiles: [],
      jobOpportunities: [],
      learningPaths: []
    };

    // Rechercher des profils avec des compÃ©tences similaires
    if (user.skills && user.skills.length > 0) {
      const skillNames = user.skills.map(skill => skill.name);
      
      recommendations.similarProfiles = await User.find({
        _id: { $ne: userId }, // Exclure l'utilisateur actuel
        'skills.name': { $in: skillNames }, // Profils avec des compÃ©tences similaires
        'privacySettings.isProfilePublic': true
      })
      .select('firstName lastName jobTitle skills profilePicture')
      .limit(5);
    }

    // Rechercher des opportunitÃ©s d'emploi (cette logique serait gÃ©nÃ©ralement 
    // implÃ©mentÃ©e via un service externe ou une autre collection)
    recommendations.jobOpportunities = [
      {
        title: "DÃ©veloppeur Full Stack",
        company: "TechCorp",
        requiredSkills: ["JavaScript", "React", "Node.js"]
      },
      {
        title: "IngÃ©nieur Data",
        company: "DataSolutions",
        requiredSkills: ["Python", "Machine Learning", "SQL"]
      }
    ];

    // SuggÃ©rer des parcours d'apprentissage basÃ©s sur les compÃ©tences
    recommendations.learningPaths = user.skills.map(skill => ({
      skillName: skill.name,
      suggestedCourses: [
        {
          name: `Master ${skill.name}`,
          platform: "Udemy",
          difficulty: "Intermediate"
        },
        {
          name: `Advanced ${skill.name} Techniques`,
          platform: "Coursera",
          difficulty: "Advanced"
        }
      ]
    }));

    res.status(200).json(recommendations);
  } catch (error) {
    res.status(500).json({ message: 'Erreur lors de la rÃ©cupÃ©ration des recommandations', error: error.message });
  }
};

// ðŸ“Œ Mettre Ã  jour les paramÃ¨tres de confidentialitÃ©
const updatePrivacySettings = async (req, res) => {
  try {
    const userId = req.user.id;
    const { 
      profileVisibility, 
      contactInfoVisibility, 
      experiencesVisibility 
    } = req.body;

    const updatedUser = await User.findByIdAndUpdate(
      userId,
      { 
        privacySettings: {
          profileVisibility,
          contactInfoVisibility,
          experiencesVisibility
        }
      },
      { new: true }
    );

    res.status(200).json(updatedUser.privacySettings);
  } catch (error) {
    res.status(500).json({ 
      message: 'Erreur lors de la mise Ã  jour des paramÃ¨tres de confidentialitÃ©', 
      error: error.message 
    });
  }
};

// Exporter toutes les mÃ©thodes du contrÃ´leur
module.exports = {
  getUserProfile,
  updateProfile,
  updatePassword,
  addExperience,
  deleteExperience,
  addEducation,
  deleteEducation,
  addSkill,
  deleteSkill,
  updateSocialLinks,
  uploadCV,
  deleteCV,
  addRating,
  toggleProfilePrivacy,
  getPublicProfile,
  getProfileRecommendations,
  updatePrivacySettings
};